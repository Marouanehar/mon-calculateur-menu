function calculateAll(d25, d26) {
            globalData = []; productData = [];
            cdgSums = { 2025: {}, 2026: {} }; orientSums = { 2025: {}, 2026: {} }; orientArticleSums = { 2025: {}, 2026: {} }; orientTotals = { 2025: {}, 2026: {} }; brutMatrix = { 2025: {}, 2026: {} }; chariotCA = { 2025: 0, 2026: 0 }; realLivTotal = { 2025: 0, 2026: 0 };

            const agg = (data, year) => {
                data.forEach(row => {
                    const ca = parseFloat(row['CA HT'] || row['CA'] || 0);
                    const siteFull = (row['Nom Site'] || "").toUpperCase();
                    const code = String(row['Code article'] || row['Code'] || "");
                    
                    // --- CORRECTION ICI : Élargissement de la détection du nom ---
                    const name = row['Désignation'] || row['Article'] || row['Libellé'] || row['Libellé Article'] || row['Nom Article'] || row['Libelle'] || row['Désignation article'] || "NOM INCONNU";
                    
                    const famFromRow = (row['Famille'] || "").toUpperCase();
                    
                    if (siteFull.includes("LIVRAISON")) realLivTotal[year] += ca;
                    let site = SITES_LIST.find(s => siteFull.includes(s)) || (siteFull.includes("CHARIOT") ? "CHARIOT" : "RABAT SIÈGE");
                    
                    const info = families[code] || { famille: famFromRow || "AUTRES", type: "RESTO" };
                    
                    pushData(site, info.famille, ca, year, info.type);
                    updateProduct(site, info.famille, code, name, ca, year);

                    if (site === "CHARIOT") chariotCA[year] += ca;
                    if (site === "RABAT SIÈGE") {
                        brutMatrix[year][info.famille] = (brutMatrix[year][info.famille] || 0) + ca;
                        const disp = dispatchMaps[year][code];
                        if(disp) disp.forEach(i => cdgSums[year][i.family] = (cdgSums[year][i.family] || 0) + (ca * i.ratio));
                        if(ORIENT_CONFIG[code]) { 
                            const cfg = ORIENT_CONFIG[code]; 
                            orientArticleSums[year][info.famille] = (orientArticleSums[year][info.famille] || 0) + ca; 
                            orientTotals[year][cfg.name] = (orientTotals[year][cfg.name] || 0) + ca; 
                            Object.keys(cfg.split).forEach(fam => orientSums[year][fam] = (orientSums[year][fam] || 0) + (ca * cfg.split[fam])); 
                        }
                    }
                });
            };
            agg(d25, 2025); agg(d26, 2026);
            renderAll();
            initFocusFilters();
        }

        function updateProduct(site, famille, code, name, ca, year) {
            let found = productData.find(p => p.code === code && p.site === site);
            if (!found) {
                // On initialise avec le nom trouvé, même s'il est inconnu au début
                found = { code, name: name, site, famille, ca25: 0, ca26: 0 };
                productData.push(found);
            }
            
            // --- CORRECTION ICI : Si le nom actuel est inconnu mais qu'on trouve un vrai nom dans une autre ligne, on écrase ---
            if (name !== "NOM INCONNU" && (found.name === "NOM INCONNU" || !found.name)) {
                found.name = name;
            }
            
            if (famille !== "AUTRES") found.famille = famille;
            if (year === 2025) found.ca25 += ca; else found.ca26 += ca;
        }
