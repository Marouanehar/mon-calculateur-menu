// 1. On s'assure que la Base Familles capture bien la Désignation
function parseBaseFam(rows) { 
    let map = {}; 
    rows.forEach(r => { 
        const c = String(r['Code article'] || r['Code'] || "");
        const f = (r['Famille'] || "").toUpperCase(); 
        // On capture le nom depuis le référentiel (Désignation, Nom, etc.)
        const n = r['Désignation'] || r['DESIGNATION'] || r['Article'] || r['Libellé'] || "";
        
        if(c) map[c] = { 
            famille: f, 
            type: f.includes("BAR") || f.includes("BOISSON") ? "BAR" : "RESTO",
            nomReferentiel: n 
        }; 
    }); 
    return map; 
}

// 2. On enrichit la détection du nom dans le calcul global
function calculateAll(d25, d26) {
    globalData = []; productData = [];
    cdgSums = { 2025: {}, 2026: {} }; orientSums = { 2025: {}, 2026: {} }; orientArticleSums = { 2025: {}, 2026: {} }; orientTotals = { 2025: {}, 2026: {} }; brutMatrix = { 2025: {}, 2026: {} }; chariotCA = { 2025: 0, 2026: 0 }; realLivTotal = { 2025: 0, 2026: 0 };

    const agg = (data, year) => {
        data.forEach(row => {
            const ca = parseFloat(row['CA HT'] || row['CA'] || 0);
            const siteFull = (row['Nom Site'] || "").toUpperCase();
            const code = String(row['Code article'] || row['Code'] || "");
            const famFromRow = (row['Famille'] || "").toUpperCase();
            
            if (siteFull.includes("LIVRAISON")) realLivTotal[year] += ca;
            let site = SITES_LIST.find(s => siteFull.includes(s)) || (siteFull.includes("CHARIOT") ? "CHARIOT" : "RABAT SIÈGE");
            
            const info = families[code] || { famille: famFromRow || "AUTRES", type: "RESTO", nomReferentiel: "" };
            
            // Priorité : Nom du référentiel > Colonnes communes > "NOM INCONNU"
            const name = info.nomReferentiel || row['Désignation'] || row['DESIGNATION'] || row['Article'] || row['Libellé'] || row['Nom'] || "NOM INCONNU";
            
            pushData(site, info.famille, ca, year, info.type);
            updateProduct(site, info.famille, code, name, ca, year);

            if (site === "CHARIOT") chariotCA[year] += ca;
            if (site === "RABAT SIÈGE") {
                brutMatrix[year][info.famille] = (brutMatrix[year][info.famille] || 0) + ca;
                const disp = dispatchMaps[year][code];
                if(disp) disp.forEach(i => cdgSums[year][i.family] = (cdgSums[year][i.family] || 0) + (ca * i.ratio));
                if(ORIENT_CONFIG[code]) { 
                    const cfg = ORIENT_CONFIG[code]; 
                    orientArticleSums[year][info.famille] = (orientArticleSums[year][info.famille] || 0) + ca; 
                    orientTotals[year][cfg.name] = (orientTotals[year][cfg.name] || 0) + ca; 
                    Object.keys(cfg.split).forEach(fam => orientSums[year][fam] = (orientSums[year][fam] || 0) + (ca * cfg.split[fam])); 
                }
            }
        });
    };
    agg(d25, 2025); agg(d26, 2026);
    renderAll();
    initFocusFilters();
}

// 3. On sécurise la mise à jour pour ne jamais perdre un nom déjà trouvé
function updateProduct(site, famille, code, name, ca, year) {
    let found = productData.find(p => p.code === code && p.site === site);
    if (!found) {
        found = { code, name: name, site, famille, ca25: 0, ca26: 0 };
        productData.push(found);
    }
    // Si le nom était inconnu et qu'on vient de trouver un vrai nom (ex: en traitant 2026), on met à jour
    if (name !== "NOM INCONNU" && (found.name === "NOM INCONNU" || !found.name)) {
        found.name = name;
    }
    if (famille !== "AUTRES") found.famille = famille;
    if (year === 2025) found.ca25 += ca; else found.ca26 += ca;
}
